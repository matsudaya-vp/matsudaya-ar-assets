<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>AR Photo Capture (FullHD)</title>
<style>
  :root {
    --button-height: 64px; /* 固定ボタン高さ（ピクセル指定でクロスブラウザで安定） */
    --button-width: 220px;
    --button-radius: 999px;
    --button-bottom-gap: calc(env(safe-area-inset-bottom, 0px) + 12px); /* ノッチ対応 */
  }

  html,body {
    height:100%;
    margin:0;
    background:#000;
    -webkit-user-select:none;
    -ms-user-select:none;
    user-select:none;
    touch-action: manipulation;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    color:#fff;
  }

  /* ビデオを含むラッパー。上下が見切れても良い仕様のため overflow:hidden */
  .cam-wrap {
    position:relative;
    width:100vw;
    height:100vh;
    overflow:hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#000;
  }

  /* video要素は幅100vwに合わせ、高さは自動。これにより等倍表示（ズームなし）に近づける。 */
  video#preview {
    width:100vw;
    height:auto; /* 高さは元解像度のアスペクト比に従う */
    object-fit: none; /* ブラウザが拡大縮小して中身を見せるのを制御（ここはnoneで等倍に近づける） */
    transform-origin:center center;
    -webkit-transform-origin:center center;
    /* iOS Safari で video を回転させる必要がある端末があるため transform の調整は後で行う（必要時） */
  }

  /* PNGオーバーレイ。中央配置、縦横比維持。幅は画面幅に合わせる（仕様） */
  img#overlay {
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:100vw; /* 画面幅を基準に */
    height:auto;
    pointer-events:none;
    max-height:100vh; /* 画面全体をはみ出すのを抑制（縦長画像対応） */
  }

  /* 撮影ボタン（下部に固定）*/
  .controls {
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom: var(--button-bottom-gap);
    z-index: 40;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }

  button#shutter {
    height: var(--button-height);
    width: var(--button-width);
    border-radius: var(--button-radius);
    border: none;
    background: linear-gradient(180deg, #ffffff 0%, #e6e6e6 100%);
    color:#111;
    font-weight:600;
    font-size:16px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    -webkit-appearance: none;
    appearance: none;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    touch-action: manipulation;
  }

  button#shutter:active {
    transform: translateY(1px) scale(.998);
  }

  /* エラーメッセージ / 状態表示 */
  #msg {
    position:fixed;
    left:12px;
    top:12px;
    z-index:50;
    background:rgba(0,0,0,0.4);
    padding:8px 10px;
    border-radius:8px;
    font-size:14px;
  }

  @media (orientation:landscape) {
    /* ランドスケープ時でもボタン位置が同じに見えるよう調整する */
    .controls { bottom: var(--button-bottom-gap); }
  }

  /* ボタンの大きさを端末ごとにより一致させたい場合は高DPI対応で下記を調整可能 */
</style>
</head>
<body>
  <div id="msg">カメラ起動中...</div>

  <div class="cam-wrap" id="camWrap">
    <video id="preview" autoplay playsinline muted></video>
    <!-- オーバーレイ画像（同一フォルダに pf-takasugi2.png を置いてください） -->
    <img id="overlay" src="pf-takasugi2.png" alt="overlay" />
  </div>

  <div class="controls" aria-hidden="false">
    <button id="shutter" type="button" aria-label="撮影">撮影</button>
  </div>

<script>
/*
  動作の流れ（要点）
  - getUserMedia({ video: { facingMode: { exact: "environment" } }}) で背面カメラを要求
  - video要素の実際の解像度（videoWidth/videoHeight）を取得
  - 1920x1080（FullHD, landscape）キャンバスを作成
  - videoの中央領域を、target aspect (16:9) に合わせて切り出し -> canvasに描画
  - overlay png をキャンバス中央に、画面幅を基準にしたスケールで重ねる
  - canvas.toBlob でダウンロード（ファイル名は yyyy-mm-dd HH-MM-SS）
  - 注意：ブラウザ/端末の向きや video の回転は完全に統一できない場合あり（多くの端末で動作する実装）
*/

(function(){
  const video = document.getElementById('preview');
  const overlay = document.getElementById('overlay');
  const shutter = document.getElementById('shutter');
  const msg = document.getElementById('msg');

  let stream = null;
  let overlayImg = new Image();
  overlayImg.src = overlay.src;
  overlayImg.onload = () => {
    // nothing for now
  };

  // カメラ開始
  async function startCamera() {
    try {
      // facingMode: environment をできるだけ尊重。exact が失敗する端末もあるため try/catchしてフォールバック。
      const constraintsPref = {
        audio: false,
        video: {
          facingMode: { exact: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        }
      };

      try {
        stream = await navigator.mediaDevices.getUserMedia(constraintsPref);
      } catch (e) {
        // exactが通らない場合のフォールバック
        const constraintsFallback = {
          audio:false,
          video: {
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        };
        stream = await navigator.mediaDevices.getUserMedia(constraintsFallback);
      }

      video.srcObject = stream;
      video.setAttribute('playsinline', ''); // iOSでフルスクリーンにならないように
      video.muted = true;
      await video.play();

      msg.textContent = 'カメラ準備OK';
      // iOS Safari 等で video の向きが異なる機種があるため、メタデータ取得後に微調整する余地あり
    } catch (err) {
      console.error(err);
      msg.textContent = 'カメラを起動できません: ' + (err && err.message ? err.message : err);
      alert('カメラへのアクセスが許可されていないか、デバイスが対応していません。ブラウザの設定を確認してください。');
    }
  }

  // utility: pad zero
  function z(n, len=2){ return String(n).padStart(len,'0'); }

  // timestamp ファイル名 'yyyy-mm-dd HH-MM-SS'
  function filenameWithTimestamp() {
    const d = new Date();
    const name = `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())} ${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}.png`;
    return name;
  }

  // 撮影処理
  async function captureFullHD() {
    if (!video || !video.videoWidth || !video.videoHeight) {
      alert('カメラがまだ準備できていません。少し待ってからもう一度お試しください。');
      return;
    }

    // target canvas size (FullHD landscape)
    const targetW = 1920;
    const targetH = 1080;
    const targetRatio = targetW / targetH;

    const vW = video.videoWidth;
    const vH = video.videoHeight;
    const videoRatio = vW / vH;

    // 中央を基準に、targetRatio に合うソース（video上の切り出し領域）を計算
    let sx, sy, sw, sh;
    if (videoRatio > targetRatio) {
      // videoが横長 => 高さ全体を使い、幅を切り出す
      sh = vH;
      sw = Math.round(vH * targetRatio);
      sx = Math.round((vW - sw) / 2);
      sy = 0;
    } else {
      // videoが縦長 or 等比 => 幅全体を使い、高さを切り出す
      sw = vW;
      sh = Math.round(vW / targetRatio);
      sx = 0;
      sy = Math.round((vH - sh) / 2);
    }

    // Canvasへ描画
    const canvas = document.createElement('canvas');
    canvas.width = targetW;
    canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // 背景を黒でクリア
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,targetW,targetH);

    // video -> canvas (中央切り出し -> 1920x1080に拡大/縮小)
    try {
      ctx.drawImage(video, sx, sy, sw, sh, 0, 0, targetW, targetH);
    } catch (e) {
      console.error('drawImage(video) failed', e);
      alert('画像処理に失敗しました');
      return;
    }

    // overlay を、"画面幅を基準にしたサイズ" で中央に描画する
    // 画面幅 (display) に合わせて overlay の幅を決めているため
    const displayW = window.innerWidth || document.documentElement.clientWidth;
    // video element の CSS 表示幅（ビデオ表示に使われている幅）は普通 displayW
    const videoDisplayWidth = displayW;
    // canvasの幅 (1920) が video の切り出し幅 sw に対応している。
    // よって overlay の canvas上の幅は： overlayCanvasW = 1920 * (overlayDisplayWidth / videoDisplayWidth)
    // 今回 overlayDisplayWidth = videoDisplayWidth (仕様: overlay width = screen width)
    const overlayDisplayWidth = displayW; // overlay CSS uses 100vw
    const overlayCanvasW = Math.round(targetW * (overlayDisplayWidth / videoDisplayWidth));

    // オーバーレイ画像の縦横比に合わせた高さ
    let overlayW = overlayCanvasW;
    let overlayH = Math.round(overlayW * (overlayImg.naturalHeight / overlayImg.naturalWidth || 1));

    // もし overlay がキャンバスより大きすぎる時は縮小
    if (overlayW > targetW) {
      const ratio = targetW / overlayW;
      overlayW = Math.round(overlayW * ratio);
      overlayH = Math.round(overlayH * ratio);
    }
    if (overlayH > targetH) {
      const ratio = targetH / overlayH;
      overlayW = Math.round(overlayW * ratio);
      overlayH = Math.round(overlayH * ratio);
    }

    // 中央に配置
    const dx = Math.round((targetW - overlayW) / 2);
    const dy = Math.round((targetH - overlayH) / 2);

    ctx.drawImage(overlayImg, 0, 0, overlayImg.naturalWidth, overlayImg.naturalHeight, dx, dy, overlayW, overlayH);

    // ダウンロード：toBlob -> link click
    canvas.toBlob(function(blob){
      if (!blob) { alert('画像作成に失敗しました'); return; }
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filenameWithTimestamp();
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 5000);
    }, 'image/png', 0.95);
  }

  // shutter button handler
  shutter.addEventListener('click', async function(){
    shutter.disabled = true;
    msg.textContent = '撮影中...';
    try {
      await captureFullHD();
    } catch (e) {
      console.error(e);
      alert('撮影でエラーが発生しました');
    } finally {
      msg.textContent = 'カメラ準備OK';
      shutter.disabled = false;
    }
  });

  // 起動
  startCamera();

  // 画面回転やリサイズ時にメッセージを更新（必要ならレイアウト調整）
  window.addEventListener('resize', function(){
    // overlay は CSS で 100vw にしてあるため自動追従
  });

  // 画面タップでフォーカス試行（サポートするカメラで tap-to-focus）
  document.getElementById('camWrap').addEventListener('touchstart', async (ev) => {
    if (!stream) return;
    // try to set focus if supported
    const track = stream.getVideoTracks()[0];
    const capabilities = track.getCapabilities && track.getCapabilities();
    const settings = track.getSettings && track.getSettings();
    // タップ位置ベースの focusPoint がサポートされるブラウザはまだ少ないが、試みる
    if (capabilities && capabilities.focusMode && capabilities.focusMode.includes('single-shot')) {
      try {
        await track.applyConstraints({ advanced: [{ focusMode: 'single-shot' }] });
      } catch (e) {
        // ignore
      }
    }
  }, { passive:true });

  // ページ離脱時はストリームを停止
  window.addEventListener('pagehide', () => {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
    }
  }, false);

})();
</script>
</body>
</html>
