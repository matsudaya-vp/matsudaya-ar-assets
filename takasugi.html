<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>ARフォト撮影</title>
    <style>
        /*
         * 1. 画面全体と安全領域の確保
         */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* スクロールを禁止 */
            touch-action: manipulation; /* タップの遅延などを防止 */
            background-color: black;
        }

        /*
         * 2. ビデオ要素（カメラ映像）の設定
         * 画面いっぱいに広げ、縦横比を維持しつつ画面を埋める (上下が見切れてもOK)
         */
        #videoElement {
            position: fixed;
            top: 50%;
            left: 50%;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            transform: translate(-50%, -50%);
            /* 反転なし (背面カメラ) */
            /* transform: scaleX(-1); は使用しない */
        }

        /*
         * 3. キャラクター画像の設定
         * 画面中央に表示し、縦横比を維持
         */
        #charImage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            /* clamp() を使用して、画面幅の80%か、縦横100vwの最小値に合わせてサイズを調整 */
            width: clamp(200px, 80vw, 100vh);
            height: auto; /* 縦横比を維持 */
            max-width: 100vw;
            max-height: calc(100vh - 100px); /* UIボタンと安全領域を考慮して、画面の高さより少し小さく */
        }

        /*
         * 4. UIエリア (撮影ボタン) の設定
         * 画面下部に固定し、安全領域に対応
         */
        #uiContainer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5); /* 見やすいように半透明の背景 */
            /* iOS のノッチ/ホームインジケーターなどに対応 */
            padding-bottom: constant(safe-area-inset-bottom);
            padding-bottom: env(safe-area-inset-bottom);
            display: flex;
            justify-content: center;
            align-items: center;
            padding-top: 15px;
            padding-bottom: 15px; /* ボタンの上下に適切なパディング */
        }

        /*
         * 5. 撮影ボタンの設定
         * クロスブラウザで同じ位置、サイズになるように調整
         */
        #shootButton {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: white;
            border: 5px solid red; /* 目立つように */
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transition: background-color 0.1s;
            touch-action: manipulation; /* ボタン操作をスムーズに */
        }

        #shootButton:active {
            background-color: #eee;
        }

        /* 撮影中などに一時的に表示するメッセージ */
        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            z-index: 30;
            display: none;
        }
    </style>
</head>
<body>

    <video id="videoElement" playsinline autoplay></video>

    <img id="charImage" src="pf-takasugi2.png" alt="キャラクター">

    <div id="uiContainer">
        <button id="shootButton"></button>
    </div>

    <div id="message">処理中...</div>

    <canvas id="photoCanvas" style="display: none;"></canvas>


    <script>
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('photoCanvas');
        const charImage = document.getElementById('charImage');
        const shootButton = document.getElementById('shootButton');
        const messageDiv = document.getElementById('message');
        const TARGET_WIDTH = 1920;
        const TARGET_HEIGHT = 1080;

        /**
         * 1. カメラの起動
         */
        async function setupCamera() {
            try {
                // 背面カメラを使用するための制約
                const constraints = {
                    video: {
                        // 可能な限り背面カメラ (exact/ideal)
                        facingMode: { exact: "environment" }, 
                        // フルHDを要求 (ideal: 希望, max: 最大)
                        width: { ideal: TARGET_WIDTH },
                        height: { ideal: TARGET_HEIGHT }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                // 動画のメタデータがロードされるのを待つ
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                console.log('カメラ起動成功');
            } catch (err) {
                console.error('カメラアクセスエラー:', err);
                alert('カメラへのアクセスを許可してください。\n(HTTPS接続が必要です)');
            }
        }

        /**
         * 2. 撮影処理
         */
        function takePhoto() {
            // 連打防止とフィードバック
            shootButton.disabled = true;
            messageDiv.textContent = '撮影・合成中...';
            messageDiv.style.display = 'block';

            // キャンバスの設定
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d');

            // --- 背景 (カメラ映像) の描画 ---

            const videoRatio = video.videoWidth / video.videoHeight;
            const canvasRatio = TARGET_WIDTH / TARGET_HEIGHT;

            let drawW, drawH, sx, sy, sWidth, sHeight;

            // 6. 撮影画像は画面中央を基準に切り出し (キャンバスのアスペクト比に合わせて中央をクロップ)
            if (videoRatio > canvasRatio) {
                // カメラ映像がキャンバスよりも横長の場合 (上下を切り出す)
                sHeight = video.videoHeight;
                sWidth = video.videoHeight * canvasRatio;
                sx = (video.videoWidth - sWidth) / 2;
                sy = 0;
            } else {
                // カメラ映像がキャンバスよりも縦長の場合 (左右を切り出す)
                sWidth = video.videoWidth;
                sHeight = video.videoWidth / canvasRatio;
                sx = 0;
                sy = (video.videoHeight - sHeight) / 2;
            }

            // カメラ映像をフルHDキャンバスに描画
            ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, TARGET_WIDTH, TARGET_HEIGHT);


            // --- キャラクター画像の描画 ---
            
            // 画面表示時のキャラクターサイズと位置を取得
            const charRect = charImage.getBoundingClientRect();

            // 画面解像度とフルHD解像度の比率
            const scaleX = TARGET_WIDTH / window.innerWidth;
            const scaleY = TARGET_HEIGHT / window.innerHeight;

            // フルHDキャンバス上でのキャラクター画像のサイズと位置を計算
            const charDrawWidth = charRect.width * scaleX;
            const charDrawHeight = charRect.height * scaleY;
            const charDrawX = charRect.left * scaleX;
            const charDrawY = charRect.top * scaleY;

            // キャラクター画像を描画
            // 画像がまだロードされていない場合は、ロードが完了してから処理する必要があるが、
            // HTMLの<img>タグで表示されているため、ここではロード済みと仮定する。
            ctx.drawImage(charImage, charDrawX, charDrawY, charDrawWidth, charDrawHeight);


            // 3. ダウンロード (Blobとaタグを使用)
            canvas.toBlob(blob => {
                if (blob) {
                    const timestamp = getTimestampFilename();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ARPhoto_${timestamp}.png`;

                    // 自動ダウンロード (一時的に DOM に追加してクリック)
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url); // メモリ解放

                    messageDiv.textContent = '撮影完了！';
                    setTimeout(() => messageDiv.style.display = 'none', 1000);
                } else {
                    alert('画像ファイルの作成に失敗しました。');
                }
                shootButton.disabled = false;
            }, 'image/png');
        }

        /**
         * タイムスタンプ付きファイル名を作成
         * 形式: yyyy-mm-dd HH-MM-SS
         */
        function getTimestampFilename() {
            const now = new Date();
            const pad = (n) => n.toString().padStart(2, '0');

            const year = now.getFullYear();
            const month = pad(now.getMonth() + 1);
            const day = pad(now.getDate());
            const hour = pad(now.getHours());
            const minute = pad(now.getMinutes());
            const second = pad(now.getSeconds());

            return `${year}-${month}-${day} ${hour}-${minute}-${second}`;
        }

        // --- イベントリスナーの設定 ---
        shootButton.addEventListener('click', takePhoto);
        window.addEventListener('load', setupCamera);

        // キャラクター画像のロードエラーハンドリング (念のため)
        charImage.onerror = () => {
            alert('キャラクター画像 (pf-takasugi2.png) の読み込みに失敗しました。ファイルがサーバーに存在するか確認してください。');
        };

        // UI崩れを防ぐため、リサイズ時にもビデオ要素の位置を再調整
        window.addEventListener('resize', () => {
            // CSSで対応しているため不要なことが多いが、念のため
        });
    </script>

</body>
</html>