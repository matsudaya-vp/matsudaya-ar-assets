<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sinsaku Takasugi Photo Frame</title>

<style>
  /* CSS変数で一元管理 */
  :root {
    --button-size: 15vw;
    --button-position: 80dvh;
    --button-color: #E0E0E0;
    --button-border-color: #808080;
  }

  body { 
    margin: 0; 
    overflow: hidden; 
    background: #000;
    touch-action: manipulation; /* タッチ遅延を削減 */
  }

  /* メディア要素の共通スタイル */
  #video-feed, #character-overlay {
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    object-fit: cover;
    will-change: transform; /* GPU加速の最適化 */
  }

  #video-feed { z-index: 1; }
  #character-overlay { z-index: 2; }

  #ui-container {
    position: fixed;
    top: calc(var(--button-position) - 1vw);
    width: 100%;
    display: flex;
    justify-content: center;
    z-index: 3;
  }

  #capture-button {
    width: var(--button-size);
    height: var(--button-size);
    padding: 0;
    font-size: 0;
    border-radius: 50%;
    cursor: pointer;
    background: var(--button-color);
    border: 4px double var(--button-border-color);
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    transform: translateY(-50%);
    transition: opacity 0.2s ease; /* スムーズなフィードバック */
    user-select: none;
  }

  #capture-button:active {
    opacity: 0.7;
  }

  /* loading状態の表示 */
  .loading {
    opacity: 0.5;
    pointer-events: none;
  }

  /* エラーメッセージのスタイル */
  .error-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    z-index: 10;
    text-align: center;
    font-family: Arial, sans-serif;
    max-width: 80%;
  }
</style>
</head>

<body>
<video id="video-feed" autoplay playsinline muted></video>
<img id="character-overlay" src="pf-takasugi2.png" alt="高杉晋作">
<div id="ui-container">
  <button id="capture-button" aria-label="写真を撮影"></button>
</div>

<script>
'use strict';

/**
 * 写真フレームアプリケーションクラス
 * ARフレーム機能と撮影機能を提供
 */
class PhotoFrameApp {
  constructor() {
    // DOM要素の取得
    this.video = document.getElementById('video-feed');
    this.overlay = document.getElementById('character-overlay');
    this.captureButton = document.getElementById('capture-button');
    
    // 撮影設定（定数として定義）
    this.CAPTURE_CONFIG = {
      width: 1080,
      height: 1920,
      quality: 0.95,
      format: 'image/png'
    };
    
    // カメラ設定
    this.CAMERA_CONFIG = {
      video: {
        facingMode: 'environment',
        width: { ideal: 2436 },
        height: { ideal: 1125 }
      }
    };
    
    // 状態管理
    this.isCapturing = false;
    this.stream = null;
    
    // 初期化
    this.init();
  }

  /**
   * アプリケーションの初期化
   */
  async init() {
    try {
      await this.initializeCamera();
      this.setupEventListeners();
      await this.preloadOverlayImage();
    } catch (error) {
      this.handleError('アプリケーションの初期化に失敗しました', error);
    }
  }

  /**
   * カメラの初期化
   */
  async initializeCamera() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia(this.CAMERA_CONFIG);
      this.video.srcObject = this.stream;
      
      // ビデオが準備完了するまで待機
      await new Promise((resolve, reject) => {
        this.video.addEventListener('loadedmetadata', resolve, { once: true });
        this.video.addEventListener('error', reject, { once: true });
        setTimeout(() => reject(new Error('Video loading timeout')), 10000);
      });
      
    } catch (error) {
      throw new Error(`カメラアクセスエラー: ${error.message}`);
    }
  }

  /**
   * オーバーレイ画像の事前読み込み
   */
  async preloadOverlayImage() {
    return new Promise((resolve, reject) => {
      if (this.overlay.complete) {
        resolve();
      } else {
        this.overlay.addEventListener('load', resolve, { once: true });
        this.overlay.addEventListener('error', reject, { once: true });
        // タイムアウト設定
        setTimeout(() => reject(new Error('Image loading timeout')), 5000);
      }
    });
  }

  /**
   * イベントリスナーの設定
   */
  setupEventListeners() {
    // 撮影ボタン（デバウンス処理付き）
    this.captureButton.addEventListener('click', 
      this.debounce(this.handleCapture.bind(this), 300)
    );

    // 画面向き変更対応（パフォーマンス最適化）
    window.addEventListener('orientationchange', 
      this.debounce(this.handleOrientationChange.bind(this), 100)
    );

    // ページの可視性変更対応
    document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
  }

  /**
   * デバウンス関数（連続実行防止）
   */
  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  /**
   * 撮影処理のメインハンドラ
   */
  async handleCapture() {
    if (this.isCapturing) return;
    
    try {
      this.isCapturing = true;
      this.captureButton.classList.add('loading');
      
      const imageBlob = await this.capturePhoto();
      this.downloadImage(imageBlob);
      
    } catch (error) {
      this.handleError('撮影に失敗しました', error);
    } finally {
      this.isCapturing = false;
      this.captureButton.classList.remove('loading');
    }
  }

  /**
   * 写真撮影処理（最適化済み）
   */
  async capturePhoto() {
    const { width: HD_W, height: HD_H } = this.CAPTURE_CONFIG;
    
    // OffscreenCanvasを使用（利用可能な場合）
    const canvas = typeof OffscreenCanvas !== 'undefined' 
      ? new OffscreenCanvas(HD_W, HD_H)
      : document.createElement('canvas');
    
    if (canvas instanceof HTMLCanvasElement) {
      canvas.width = HD_W;
      canvas.height = HD_H;
    }
    
    const ctx = canvas.getContext('2d', { 
      alpha: false,  // 透明度不要でパフォーマンス向上
      willReadFrequently: false 
    });

    // 背景（ビデオ）の描画
    this.drawVideoToCanvas(ctx, HD_W, HD_H);
    
    // オーバーレイの描画
    this.drawOverlayToCanvas(ctx, HD_W, HD_H);

    // Blobとして返す（メモリ効率向上）
    if (canvas.convertToBlob) {
      return await canvas.convertToBlob({ 
        type: this.CAPTURE_CONFIG.format,
        quality: this.CAPTURE_CONFIG.quality 
      });
    } else {
      return new Promise(resolve => {
        canvas.toBlob(resolve, this.CAPTURE_CONFIG.format, this.CAPTURE_CONFIG.quality);
      });
    }
  }

  /**
   * ビデオをキャンバスに描画（中央クロップ）
   */
  drawVideoToCanvas(ctx, canvasWidth, canvasHeight) {
    const videoRatio = this.video.videoWidth / this.video.videoHeight;
    const canvasRatio = canvasWidth / canvasHeight;

    let srcW, srcH, srcX, srcY;
    
    if (videoRatio > canvasRatio) {
      srcH = this.video.videoHeight;
      srcW = srcH * canvasRatio;
      srcX = (this.video.videoWidth - srcW) / 2;
      srcY = 0;
    } else {
      srcW = this.video.videoWidth;
      srcH = srcW / canvasRatio;
      srcX = 0;
      srcY = (this.video.videoHeight - srcH) / 2;
    }

    ctx.drawImage(this.video, srcX, srcY, srcW, srcH, 0, 0, canvasWidth, canvasHeight);
  }

  /**
   * オーバーレイをキャンバスに描画（中央クロップ）
   */
  drawOverlayToCanvas(ctx, canvasWidth, canvasHeight) {
    const imgRatio = this.overlay.naturalWidth / this.overlay.naturalHeight;
    const canvasRatio = canvasWidth / canvasHeight;

    let imgW, imgH, imgX, imgY;
    
    if (imgRatio > canvasRatio) {
      imgH = this.overlay.naturalHeight;
      imgW = imgH * canvasRatio;
      imgX = (this.overlay.naturalWidth - imgW) / 2;
      imgY = 0;
    } else {
      imgW = this.overlay.naturalWidth;
      imgH = imgW / canvasRatio;
      imgX = 0;
      imgY = (this.overlay.naturalHeight - imgH) / 2;
    }

    ctx.drawImage(this.overlay, imgX, imgY, imgW, imgH, 0, 0, canvasWidth, canvasHeight);
  }

  /**
   * 画像のダウンロード処理
   */
  downloadImage(blob) {
    const timestamp = new Date().toISOString()
      .replace(/[-:T]/g, '')
      .slice(0, 14);
    
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    link.download = `matsudaya_photo_${timestamp}.png`;
    link.href = url;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // メモリリーク防止
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }

  /**
   * 画面向き変更時の処理
   */
  handleOrientationChange() {
    // 必要に応じてUIの再調整
    console.log('Orientation changed');
  }

  /**
   * ページ可視性変更時の処理
   */
  handleVisibilityChange() {
    if (document.hidden && this.stream) {
      // バックグラウンド時はカメラを一時停止してリソースを節約
      const tracks = this.stream.getVideoTracks();
      tracks.forEach(track => track.enabled = false);
    } else if (!document.hidden && this.stream) {
      // フォアグラウンド復帰時はカメラを再開
      const tracks = this.stream.getVideoTracks();
      tracks.forEach(track => track.enabled = true);
    }
  }

  /**
   * エラーハンドリング
   */
  handleError(message, error) {
    console.error(message, error);
    
    // エラーメッセージの表示
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.innerHTML = `
      <h3>エラーが発生しました</h3>
      <p>${message}</p>
      <button onclick="this.parentElement.remove()" style="margin-top:10px; padding:5px 10px;">閉じる</button>
    `;
    
    document.body.appendChild(errorDiv);
    
    // 5秒後に自動的に削除
    setTimeout(() => {
      if (errorDiv.parentElement) {
        errorDiv.remove();
      }
    }, 5000);
  }

  /**
   * リソースのクリーンアップ
   */
  cleanup() {
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
      this.stream = null;
    }
  }
}

// アプリケーションの開始
let app;
document.addEventListener('DOMContentLoaded', () => {
  app = new PhotoFrameApp();
});

// ページ離脱時のクリーンアップ
window.addEventListener('beforeunload', () => {
  if (app) {
    app.cleanup();
  }
});

</script>
</body>
</html>