<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sinsaku Takasugi Photo Frame</title>

<style>
  /* 元の基本構造を維持 */
  body { 
    margin: 0; 
    overflow: hidden; 
    background: #000; 
    touch-action: manipulation;
  }

  /* 元の表示方式を復元 */
  #video-feed, #character-overlay {
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    object-fit: cover;
    z-index: 1;
  }

  #character-overlay { 
    z-index: 2; 
    /* PNG透過保持 */
    background: transparent;
  }

  /* 改善されたボタン配置システム */
  :root {
    --button-bottom: 120px;
    --button-size-base: 15vw;
    --button-size-min: 60px;
    --button-size-max: 120px;
  }

  /* デバイス別プリセット */
  /* iPhone SE (375x667) */
  @media (max-width: 375px) and (max-height: 667px) {
    :root { 
      --button-bottom: 100px;
      --button-size-base: 18vw;
    }
  }

  /* iPhone 12/13/14 (390x844) */
  @media (max-width: 390px) and (min-height: 844px) {
    :root { 
      --button-bottom: 130px;
      --button-size-base: 16vw;
    }
  }

  /* iPhone 12/13/14 Pro Max (428x926) */
  @media (max-width: 428px) and (min-height: 926px) {
    :root { 
      --button-bottom: 140px;
      --button-size-base: 15vw;
    }
  }

  /* Android 大画面 */
  @media (min-width: 400px) and (min-height: 900px) {
    :root { 
      --button-bottom: 150px;
      --button-size-base: 12vw;
    }
  }

  /* 小さい画面全般 */
  @media (max-height: 600px) {
    :root {
      --button-bottom: 80px;
      --button-size-base: 16vw;
    }
  }

  /* 横向き対応 */
  @media (orientation: landscape) {
    :root {
      --button-bottom: 60px;
      --button-size-base: 12vh;
      --button-size-max: 80px;
    }
  }

  /* 横向き + 小さい画面 */
  @media (orientation: landscape) and (max-height: 500px) {
    :root {
      --button-bottom: 40px;
      --button-size-base: 10vh;
    }
  }

  #ui-container {
    position: fixed;
    bottom: calc(var(--button-bottom) + env(safe-area-inset-bottom, 0px));
    left: 50%;
    transform: translateX(-50%);
    z-index: 3;
    /* コンテナクエリ対応 */
    container-type: inline-size;
  }

  /* フォールバック対応（古いブラウザ） */
  @supports not (bottom: env(safe-area-inset-bottom)) {
    #ui-container {
      bottom: var(--button-bottom);
    }
  }

  #capture-button {
    width: clamp(var(--button-size-min), var(--button-size-base), var(--button-size-max));
    height: clamp(var(--button-size-min), var(--button-size-base), var(--button-size-max));
    padding: 0;
    font-size: 0;
    border-radius: 50%;
    cursor: pointer;
    background: #E0E0E0;
    color: transparent; 
    border: 4px double #808080;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    transition: all 0.2s ease;
    user-select: none;
    /* タッチ領域を確保（アクセシビリティ） */
    min-width: 44px;
    min-height: 44px;
    /* タッチ最適化 */
    touch-action: manipulation;
  }

  #capture-button:active {
    transform: scale(0.95);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }

  /* 改善機能のスタイル */
  .progress-overlay {
    position: fixed;
    bottom: calc(20px + env(safe-area-inset-bottom, 0px));
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    z-index: 4;
    display: none;
    font-size: 14px;
    white-space: nowrap;
  }

  .camera-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: white;
    z-index: 9999;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.1s ease;
  }

  .flash-active {
    opacity: 0.7;
  }

  .error-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(244, 67, 54, 0.95);
    color: white;
    padding: 20px;
    border-radius: 12px;
    z-index: 10;
    text-align: center;
    max-width: 80%;
    display: none;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  }

  .error-display button {
    background: rgba(255,255,255,0.2);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    padding: 8px 16px;
    border-radius: 6px;
    margin-top: 10px;
    cursor: pointer;
  }

  .button-processing {
    opacity: 0.7;
    pointer-events: none;
  }

  /* 追加：デバッグ情報表示（開発時のみ） */
  .debug-info {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px;
    font-size: 12px;
    border-radius: 4px;
    z-index: 5;
    display: none; /* 本番では非表示 */
  }
</style>
</head>

<body>
<video id="video-feed" autoplay playsinline muted></video>
<img id="character-overlay" src="pf-takasugi2.png" alt="高杉晋作">
<div id="ui-container">
  <button id="capture-button" aria-label="写真を撮影"></button>
</div>

<!-- 改善機能の要素 -->
<div id="progress-overlay" class="progress-overlay"></div>
<div id="camera-flash" class="camera-flash"></div>
<div id="error-display" class="error-display"></div>
<div id="debug-info" class="debug-info"></div>

<script>
'use strict';

/**
 * 改善されたPhotoFrameアプリ
 * 元の動作を保持しつつ、安定したボタン配置システムを実装
 */
class ImprovedPhotoFrame {
  constructor() {
    // DOM要素の取得
    this.video = document.getElementById('video-feed');
    this.overlay = document.getElementById('character-overlay');
    this.captureButton = document.getElementById('capture-button');
    this.progressOverlay = document.getElementById('progress-overlay');
    this.cameraFlash = document.getElementById('camera-flash');
    this.errorDisplay = document.getElementById('error-display');
    this.debugInfo = document.getElementById('debug-info');
    this.uiContainer = document.getElementById('ui-container');
    
    // 設定
    this.config = {
      capture: { width: 1080, height: 1920, quality: 0.95 },
      camera: { 
        video: { 
          facingMode: 'environment', 
          width: { ideal: 2436 }, 
          height: { ideal: 1125 } 
        } 
      },
      // デバッグモード（本番では false に設定）
      debug: false
    };
    
    // 状態管理
    this.isCapturing = false;
    this.stream = null;
    this.resizeTimeout = null;
    
    // 初期化
    this.init();
  }

  async init() {
    try {
      await this.initCamera();
      await this.waitForOverlay();
      this.setupEvents();
      this.adjustButtonPosition();
      
      if (this.config.debug) {
        this.showDebugInfo();
      }
      
      console.log('App initialized successfully');
    } catch (error) {
      this.showError('初期化に失敗しました: ' + error.message);
    }
  }

  async initCamera() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia(this.config.camera);
      this.video.srcObject = this.stream;
      
      return new Promise((resolve, reject) => {
        this.video.onloadedmetadata = () => resolve();
        this.video.onerror = () => reject(new Error('ビデオ読み込みエラー'));
        setTimeout(() => reject(new Error('カメラ初期化タイムアウト')), 10000);
      });
    } catch (error) {
      if (error.name === 'NotAllowedError') {
        throw new Error('カメラの使用が許可されていません');
      }
      throw new Error('カメラアクセスエラー: ' + error.message);
    }
  }

  async waitForOverlay() {
    if (this.overlay.complete) return;
    
    return new Promise((resolve, reject) => {
      this.overlay.onload = () => resolve();
      this.overlay.onerror = () => reject(new Error('オーバーレイ画像の読み込みに失敗'));
      setTimeout(() => reject(new Error('画像読み込みタイムアウト')), 5000);
    });
  }

  setupEvents() {
    // 撮影ボタン（シンプルなデバウンス）
    let lastClick = 0;
    this.captureButton.addEventListener('click', (e) => {
      const now = Date.now();
      if (now - lastClick < 300) return; // 300ms デバウンス
      lastClick = now;
      this.handleCapture();
    });

    // リサイズ・回転時の位置調整
    const handleResize = () => {
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = setTimeout(() => {
        this.adjustButtonPosition();
        if (this.config.debug) {
          this.showDebugInfo();
        }
      }, 100);
    };

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', () => {
      // 向き変更時は少し遅延させる（iOS対応）
      setTimeout(() => {
        this.adjustButtonPosition();
        if (this.config.debug) {
          this.showDebugInfo();
        }
      }, 300);
    });

    // ページ可視性の制御
    document.addEventListener('visibilitychange', () => {
      if (this.stream) {
        const tracks = this.stream.getVideoTracks();
        tracks.forEach(track => {
          track.enabled = !document.hidden;
        });
      }
    });

    // リソースクリーンアップ
    window.addEventListener('beforeunload', () => this.cleanup());
  }

  /**
   * 最適なボタン位置を計算
   */
  calculateOptimalButtonPosition() {
    const vh = window.innerHeight;
    const vw = window.innerWidth;
    const isLandscape = window.innerWidth > window.innerHeight;
    
    let bottomOffset;
    
    if (isLandscape) {
      // 横向きの場合
      if (vh <= 400) {
        bottomOffset = 30;
      } else if (vh <= 500) {
        bottomOffset = 40;
      } else {
        bottomOffset = 60;
      }
    } else {
      // 縦向きの場合
      if (vh <= 600) {
        // 小さい画面：固定値優先
        bottomOffset = 80;
      } else if (vh <= 667) {
        // iPhone SE サイズ
        bottomOffset = 100;
      } else if (vh <= 800) {
        // 中くらい：比例計算だが範囲制限
        bottomOffset = Math.max(100, Math.min(vh * 0.15, 130));
      } else if (vh <= 844) {
        // iPhone 12/13/14 サイズ
        bottomOffset = 130;
      } else if (vh <= 926) {
        // iPhone Pro Max サイズ
        bottomOffset = 140;
      } else {
        // 大きい画面：上限設定
        bottomOffset = Math.min(vh * 0.16, 180);
      }
    }
    
    // セーフエリアの追加
    const safeAreaBottom = this.getSafeAreaBottom();
    
    return bottomOffset + safeAreaBottom;
  }

  /**
   * セーフエリア下部の値を取得
   */
  getSafeAreaBottom() {
    // CSS env()が使えない場合の fallback
    if (!CSS.supports('padding', 'env(safe-area-inset-bottom)')) {
      // 手動でデバイス判定
      const isIPhoneX = /iPhone/.test(navigator.userAgent) && 
                        window.innerHeight >= 812;
      return isIPhoneX ? 34 : 0;
    }
    return 0; // CSSで処理される
  }

  /**
   * ボタン位置を動的に調整
   */
  adjustButtonPosition() {
    if (!CSS.supports('bottom', 'clamp(60px, 15vw, 120px)')) {
      // clamp()が使えない古いブラウザの場合はJavaScriptで制御
      const vh = window.innerHeight;
      const vw = window.innerWidth;
      const bottomOffset = this.calculateOptimalButtonPosition();
      
      this.uiContainer.style.bottom = `${bottomOffset}px`;
      
      // ボタンサイズも調整
      const isLandscape = window.innerWidth > window.innerHeight;
      let buttonSize;
      
      if (isLandscape) {
        buttonSize = Math.max(Math.min(vh * 0.12, 80), 50);
      } else {
        buttonSize = Math.max(Math.min(vw * 0.15, 120), 60);
      }
      
      this.captureButton.style.width = `${buttonSize}px`;
      this.captureButton.style.height = `${buttonSize}px`;
      
      if (this.config.debug) {
        console.log(`Manual positioning: ${bottomOffset}px from bottom, button: ${buttonSize}px (screen: ${vw}x${vh})`);
      }
    } else {
      // モダンブラウザの場合はCSSに任せる
      if (this.config.debug) {
        const computedStyle = window.getComputedStyle(this.uiContainer);
        console.log(`CSS positioning: bottom=${computedStyle.bottom}`);
      }
    }
  }

  /**
   * デバッグ情報を表示
   */
  showDebugInfo() {
    if (!this.config.debug) return;
    
    const vh = window.innerHeight;
    const vw = window.innerWidth;
    const isLandscape = window.innerWidth > window.innerHeight;
    const orientation = isLandscape ? 'landscape' : 'portrait';
    const bottomOffset = this.calculateOptimalButtonPosition();
    
    this.debugInfo.innerHTML = `
      画面: ${vw}×${vh}<br>
      向き: ${orientation}<br>
      ボタン位置: ${bottomOffset}px<br>
      UA: ${navigator.userAgent.includes('iPhone') ? 'iPhone' : 'Other'}
    `;
    this.debugInfo.style.display = 'block';
  }

  async handleCapture() {
    if (this.isCapturing) return;
    
    try {
      this.isCapturing = true;
      this.captureButton.classList.add('button-processing');
      
      // プログレス表示
      this.showProgress('撮影中...');
      
      // フラッシュエフェクト
      await this.flashEffect();
      
      // 撮影処理
      this.showProgress('画像処理中...');
      const blob = await this.capturePhoto();
      
      // ダウンロード
      this.showProgress('保存中...');
      this.downloadImage(blob);
      
      // 完了
      this.hideProgress();
      
      // ハプティックフィードバック
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
      
    } catch (error) {
      this.hideProgress();
      this.showError('撮影に失敗しました: ' + error.message);
    } finally {
      this.isCapturing = false;
      this.captureButton.classList.remove('button-processing');
    }
  }

  async capturePhoto() {
    const canvas = document.createElement('canvas');
    const { width, height, quality } = this.config.capture;
    
    canvas.width = width;
    canvas.height = height;
    
    // 透過保持のためのContext設定
    const ctx = canvas.getContext('2d', { alpha: true });
    
    // 背景を透明にクリア（重要：白で塗りつぶさない）
    ctx.clearRect(0, 0, width, height);
    
    // ビデオの描画（中央クロップ）
    this.drawCroppedImage(ctx, this.video, width, height);
    
    // オーバーレイの描画（透過保持）
    ctx.globalCompositeOperation = 'source-over';
    this.drawCroppedImage(ctx, this.overlay, width, height);
    
    // Blobに変換
    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('画像の生成に失敗しました'));
        }
      }, 'image/png', quality);
    });
  }

  drawCroppedImage(ctx, source, targetWidth, targetHeight) {
    const sourceWidth = source.videoWidth || source.naturalWidth;
    const sourceHeight = source.videoHeight || source.naturalHeight;
    
    if (!sourceWidth || !sourceHeight) {
      throw new Error('ソース画像のサイズを取得できません');
    }
    
    const sourceRatio = sourceWidth / sourceHeight;
    const targetRatio = targetWidth / targetHeight;
    
    let sx, sy, sw, sh;
    
    if (sourceRatio > targetRatio) {
      // ソースの方が横長：横をクロップ
      sh = sourceHeight;
      sw = sh * targetRatio;
      sx = (sourceWidth - sw) / 2;
      sy = 0;
    } else {
      // ソースの方が縦長：縦をクロップ
      sw = sourceWidth;
      sh = sw / targetRatio;
      sx = 0;
      sy = (sourceHeight - sh) / 2;
    }
    
    ctx.drawImage(source, sx, sy, sw, sh, 0, 0, targetWidth, targetHeight);
  }

  downloadImage(blob) {
    const timestamp = new Date().toISOString()
      .replace(/[-:T]/g, '')
      .slice(0, 14);
    
    const link = document.createElement('a');
    link.download = `matsudaya_photo_${timestamp}.png`;
    link.href = URL.createObjectURL(blob);
    
    // 一時的にDOMに追加してクリック
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // メモリクリーンアップ
    setTimeout(() => URL.revokeObjectURL(link.href), 100);
  }

  async flashEffect() {
    this.cameraFlash.classList.add('flash-active');
    await this.delay(100);
    this.cameraFlash.classList.remove('flash-active');
  }

  showProgress(message) {
    this.progressOverlay.textContent = message;
    this.progressOverlay.style.display = 'block';
  }

  hideProgress() {
    this.progressOverlay.style.display = 'none';
  }

  showError(message) {
    console.error(message);
    this.errorDisplay.innerHTML = `
      <p>${message}</p>
      <button onclick="this.parentElement.style.display='none'">閉じる</button>
    `;
    this.errorDisplay.style.display = 'block';
    
    // 5秒後に自動で閉じる
    setTimeout(() => {
      this.errorDisplay.style.display = 'none';
    }, 5000);
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  cleanup() {
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
      this.stream = null;
    }
    
    if (this.resizeTimeout) {
      clearTimeout(this.resizeTimeout);
    }
  }
}

// アプリケーション開始
let app;
document.addEventListener('DOMContentLoaded', () => {
  app = new ImprovedPhotoFrame();
});

// グローバルエラーハンドリング
window.addEventListener('error', (e) => {
  console.error('Global error:', e.error);
});

window.addEventListener('unhandledrejection', (e) => {
  console.error('Unhandled rejection:', e.reason);
});

</script>
</body>
</html>