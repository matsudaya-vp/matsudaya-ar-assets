<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sinsaku Takasugi Photo Frame</title>

<style>
  /* 元の基本構造を維持 */
  body { 
    margin: 0; 
    overflow: hidden; 
    background: #000; 
    touch-action: manipulation;
  }

  /* コンテナで画像とボタンの相対位置を管理 */
  #main-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100vw;
    height: 100vh;
    max-width: 100%;
    max-height: 100%;
  }

  /* ビデオとオーバーレイを相対位置で配置 */
  #video-feed, #character-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  #character-overlay { 
    z-index: 2;
    background: transparent;
  }

  /* ボタンコンテナを画像基準で配置 */
  #ui-container {
    position: absolute;
    bottom: 12%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 3;
  }

  #capture-button {
    /* 固定サイズでブラウザ間の差異を統一 */
    width: 80px;
    height: 80px;
    padding: 0;
    margin: 0;
    font-size: 0;
    line-height: 1;
    border-radius: 50%;
    cursor: pointer;
    background: #E0E0E0;
    color: transparent; 
    border: 4px double #808080;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    transition: all 0.2s ease;
    user-select: none;
    
    /* ブラウザ固有のスタイルをリセット */
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    outline: none;
    
    /* ボックスサイズを統一 */
    box-sizing: border-box;
    
    /* フレックスで中央揃え（念のため） */
    display: flex;
    align-items: center;
    justify-content: center;
    
    /* タッチ領域を確保 */
    min-width: 44px;
    min-height: 44px;
  }

  #capture-button:active {
    transform: scale(0.95);
  }

  #capture-button:focus {
    outline: 2px solid rgba(255, 255, 255, 0.5);
    outline-offset: 2px;
  }

  /* 小さい画面でのサイズ調整（必要最小限） */
  @media (max-width: 360px) {
    #capture-button {
      width: 70px;
      height: 70px;
    }
  }

  /* 大きい画面でのサイズ調整（必要最小限） */
  @media (min-width: 1024px) {
    #capture-button {
      width: 90px;
      height: 90px;
    }
  }

  /* 改善機能のスタイル */
  .progress-overlay {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    z-index: 4;
    display: none;
    font-size: 14px;
    box-sizing: border-box;
  }

  .camera-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: white;
    z-index: 9999;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.1s ease;
  }

  .flash-active {
    opacity: 0.7;
  }

  .error-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(244, 67, 54, 0.95);
    color: white;
    padding: 20px;
    border-radius: 12px;
    z-index: 10;
    text-align: center;
    max-width: 80%;
    display: none;
    box-sizing: border-box;
    font-size: 16px;
  }

  .button-processing {
    opacity: 0.7;
    pointer-events: none;
  }

  /* デバッグ用：アンカーポイントを可視化したい場合 */
  .debug-anchor {
    position: absolute;
    width: 4px;
    height: 4px;
    background: red;
    z-index: 999;
    display: none; /* 本番では非表示 */
  }

  .debug-anchor.bottom-center {
    bottom: 12%;
    left: 50%;
    transform: translateX(-50%);
  }

  /* 全体的なボックスサイズ統一 */
  * {
    box-sizing: border-box;
  }
</style>
</head>

<body>
<div id="main-container">
  <video id="video-feed" autoplay playsinline muted></video>
  <img id="character-overlay" src="pf-takasugi2.png" alt="高杉晋作">
  
  <!-- デバッグ用アンカーポイント（必要に応じて表示） -->
  <div class="debug-anchor bottom-center"></div>
  
  <div id="ui-container">
    <button id="capture-button" aria-label="写真を撮影"></button>
  </div>
</div>

<!-- 改善機能の要素 -->
<div id="progress-overlay" class="progress-overlay"></div>
<div id="camera-flash" class="camera-flash"></div>
<div id="error-display" class="error-display"></div>

<script>
'use strict';

/**
 * 改善されたPhotoFrameアプリ
 * ボタンサイズ統一版
 */
class ImprovedPhotoFrame {
  constructor() {
    // DOM要素の取得
    this.mainContainer = document.getElementById('main-container');
    this.video = document.getElementById('video-feed');
    this.overlay = document.getElementById('character-overlay');
    this.captureButton = document.getElementById('capture-button');
    this.progressOverlay = document.getElementById('progress-overlay');
    this.cameraFlash = document.getElementById('camera-flash');
    this.errorDisplay = document.getElementById('error-display');
    
    // 設定
    this.config = {
      capture: { width: 1080, height: 1920, quality: 0.95 },
      camera: { 
        video: { 
          facingMode: 'environment', 
          width: { ideal: 2436 }, 
          height: { ideal: 1125 } 
        } 
      }
    };
    
    // 状態管理
    this.isCapturing = false;
    this.stream = null;
    
    // 初期化
    this.init();
  }

  async init() {
    try {
      await this.initCamera();
      await this.waitForOverlay();
      this.setupEvents();
      console.log('App initialized successfully');
    } catch (error) {
      this.showError('初期化に失敗しました: ' + error.message);
    }
  }

  async initCamera() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia(this.config.camera);
      this.video.srcObject = this.stream;
      
      return new Promise((resolve, reject) => {
        this.video.onloadedmetadata = () => resolve();
        this.video.onerror = () => reject(new Error('ビデオ読み込みエラー'));
        setTimeout(() => reject(new Error('カメラ初期化タイムアウト')), 10000);
      });
    } catch (error) {
      if (error.name === 'NotAllowedError') {
        throw new Error('カメラの使用が許可されていません');
      }
      throw new Error('カメラアクセスエラー: ' + error.message);
    }
  }

  async waitForOverlay() {
    if (this.overlay.complete) return;
    
    return new Promise((resolve, reject) => {
      this.overlay.onload = () => resolve();
      this.overlay.onerror = () => reject(new Error('オーバーレイ画像の読み込みに失敗'));
      setTimeout(() => reject(new Error('画像読み込みタイムアウト')), 5000);
    });
  }

  setupEvents() {
    // 撮影ボタン（シンプルなデバウンス）
    let lastClick = 0;
    this.captureButton.addEventListener('click', (e) => {
      const now = Date.now();
      if (now - lastClick < 300) return; // 300ms デバウンス
      lastClick = now;
      this.handleCapture();
    });

    // タッチイベントでより確実な反応を提供
    this.captureButton.addEventListener('touchstart', (e) => {
      e.preventDefault(); // デフォルトの動作を防ぐ
    });

    // ページ可視性の制御
    document.addEventListener('visibilitychange', () => {
      if (this.stream) {
        const tracks = this.stream.getVideoTracks();
        tracks.forEach(track => {
          track.enabled = !document.hidden;
        });
      }
    });

    // リソースクリーンアップ
    window.addEventListener('beforeunload', () => this.cleanup());
  }

  async handleCapture() {
    if (this.isCapturing) return;
    
    try {
      this.isCapturing = true;
      this.captureButton.classList.add('button-processing');
      
      // プログレス表示
      this.showProgress('撮影中...');
      
      // フラッシュエフェクト
      await this.flashEffect();
      
      // 撮影処理
      this.showProgress('画像処理中...');
      const blob = await this.capturePhoto();
      
      // ダウンロード
      this.showProgress('保存中...');
      this.downloadImage(blob);
      
      // 完了
      this.hideProgress();
      
      // ハプティックフィードバック
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
      
    } catch (error) {
      this.hideProgress();
      this.showError('撮影に失敗しました: ' + error.message);
    } finally {
      this.isCapturing = false;
      this.captureButton.classList.remove('button-processing');
    }
  }

  async capturePhoto() {
    const canvas = document.createElement('canvas');
    const { width, height, quality } = this.config.capture;
    
    canvas.width = width;
    canvas.height = height;
    
    // 透過保持のためのContext設定
    const ctx = canvas.getContext('2d', { alpha: true });
    
    // 背景を透明にクリア（重要：白で塗りつぶさない）
    ctx.clearRect(0, 0, width, height);
    
    // ビデオの描画（中央クロップ）
    this.drawCroppedImage(ctx, this.video, width, height);
    
    // オーバーレイの描画（透過保持）
    ctx.globalCompositeOperation = 'source-over';
    this.drawCroppedImage(ctx, this.overlay, width, height);
    
    // Blobに変換
    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('画像の生成に失敗しました'));
        }
      }, 'image/png', quality);
    });
  }

  drawCroppedImage(ctx, source, targetWidth, targetHeight) {
    const sourceWidth = source.videoWidth || source.naturalWidth;
    const sourceHeight = source.videoHeight || source.naturalHeight;
    
    if (!sourceWidth || !sourceHeight) {
      throw new Error('ソース画像のサイズを取得できません');
    }
    
    const sourceRatio = sourceWidth / sourceHeight;
    const targetRatio = targetWidth / targetHeight;
    
    let sx, sy, sw, sh;
    
    if (sourceRatio > targetRatio) {
      // ソースの方が横長：横をクロップ
      sh = sourceHeight;
      sw = sh * targetRatio;
      sx = (sourceWidth - sw) / 2;
      sy = 0;
    } else {
      // ソースの方が縦長：縦をクロップ
      sw = sourceWidth;
      sh = sw / targetRatio;
      sx = 0;
      sy = (sourceHeight - sh) / 2;
    }
    
    ctx.drawImage(source, sx, sy, sw, sh, 0, 0, targetWidth, targetHeight);
  }

  downloadImage(blob) {
    const timestamp = new Date().toISOString()
      .replace(/[-:T]/g, '')
      .slice(0, 14);
    
    const link = document.createElement('a');
    link.download = `matsudaya_photo_${timestamp}.png`;
    link.href = URL.createObjectURL(blob);
    
    // 一時的にDOMに追加してクリック
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // メモリクリーンアップ
    setTimeout(() => URL.revokeObjectURL(link.href), 100);
  }

  async flashEffect() {
    this.cameraFlash.classList.add('flash-active');
    await this.delay(100);
    this.cameraFlash.classList.remove('flash-active');
  }

  showProgress(message) {
    this.progressOverlay.textContent = message;
    this.progressOverlay.style.display = 'block';
  }

  hideProgress() {
    this.progressOverlay.style.display = 'none';
  }

  showError(message) {
    console.error(message);
    this.errorDisplay.innerHTML = `
      <p>${message}</p>
      <button onclick="this.parentElement.style.display='none'">閉じる</button>
    `;
    this.errorDisplay.style.display = 'block';
    
    // 5秒後に自動で閉じる
    setTimeout(() => {
      this.errorDisplay.style.display = 'none';
    }, 5000);
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  cleanup() {
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
      this.stream = null;
    }
  }
}

// アプリケーション開始
let app;
document.addEventListener('DOMContentLoaded', () => {
  app = new ImprovedPhotoFrame();
});

// グローバルエラーハンドリング
window.addEventListener('error', (e) => {
  console.error('Global error:', e.error);
});

window.addEventListener('unhandledrejection', (e) => {
  console.error('Unhandled rejection:', e.reason);
});

</script>
</body>
</html>