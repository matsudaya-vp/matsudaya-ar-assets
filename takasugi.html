<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>ARフォトアプリ</title>
    <style>
        /* 全体のリセットとフルスクリーン設定 */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* スクロールを禁止 */
            width: 100vw;
            height: 100vh;
            background-color: #000;
            font-family: sans-serif;
        }

        /* ---------------------------------- */
        /* カメラ表示エリア */
        /* ---------------------------------- */
        .video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* 動画が見切れるように設定 */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #video {
            /* 画面全体にフィットし、縦横比を維持（上下見切れOK） */
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            object-fit: cover;
            transform: scaleX(1); /* 反転なし（背面カメラそのまま）*/
        }

        /* ---------------------------------- */
        /* キャラクターオーバーレイ */
        /* ---------------------------------- */
        #character-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* 画面中央に配置 */
            width: 80vw; /* 画面幅を基準にサイズ調整 (例: 80vw) */
            max-width: 80vh; /* 縦長キャラ対応（画面高さも考慮） */
            height: auto;
            pointer-events: none; /* 透過させて下の要素を触れるように */
            object-fit: contain; /* 縦横比を維持 */
        }

        /* ---------------------------------- */
        /* UI（撮影ボタン）エリア */
        /* ---------------------------------- */
        .ui-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            /* ノッチやホームバー対応のために safe-area-inset-bottom を使用 */
            padding-bottom: env(safe-area-inset-bottom, 20px); 
            background-color: rgba(0, 0, 0, 0.5); /* 半透明の背景 */
            text-align: center;
            padding-top: 20px;
            z-index: 10;
        }

        #capture-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: #FFF;
            border: 5px solid #F00;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            margin-bottom: 10px; /* 内部パディングに加えて微調整 */
        }
        
        /* 撮影用キャンバスは非表示 */
        #canvas {
            display: none;
        }

    </style>
</head>
<body>

    <div class="video-container">
        <video id="video" autoplay playsinline></video>
    </div>

    <img id="character-overlay" src="pf-takasugi2.png" alt="キャラクター">

    <div class="ui-container">
        <button id="capture-button" aria-label="撮影"></button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const captureButton = document.getElementById('capture-button');
        const characterOverlay = document.getElementById('character-overlay');
        const WIDTH = 1920;  // 撮影画像の幅 (フルHD)
        const HEIGHT = 1080; // 撮影画像の高さ (フルHD)

        // 1. 背面カメラの使用
        async function startCamera() {
            try {
                // 'environment' で背面カメラを指定
                const constraints = {
                    video: {
                        facingMode: 'environment'
                        // ideal resolution (オプション、ブラウザがサポートすれば適用)
                        // width: { ideal: 1920 },
                        // height: { ideal: 1080 }
                    },
                    audio: false
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                // 動画のロードが完了してから再生開始
                video.onloadedmetadata = () => {
                    video.play();
                };

            } catch (err) {
                console.error("カメラへのアクセスでエラーが発生しました: ", err);
                alert('カメラへのアクセスが必要です。ブラウザの設定を確認してください。');
            }
        }

        // 7. タイムスタンプ付きファイル名
        function getTimestamp() {
            const now = new Date();
            const pad = (n) => String(n).padStart(2, '0');
            
            const year = now.getFullYear();
            const month = pad(now.getMonth() + 1);
            const day = pad(now.getDate());
            const hour = pad(now.getHours());
            const minute = pad(now.getMinutes());
            const second = pad(now.getSeconds());

            return `${year}-${month}-${day} ${hour}-${minute}-${second}`;
        }

        // 2. 撮影ボタンでフルHD画像を作成（6. 画面中央を基準に切り出し）
        function takePicture() {
            const context = canvas.getContext('2d');
            
            // 撮影画像をフルHDに設定
            canvas.width = WIDTH;
            canvas.height = HEIGHT;

            // **撮影画像（Canvas）への描画と中央切り出しのロジック**
            
            // 1. video要素からフルHDのcanvasに映像を転写（中央切り出し）
            const videoRatio = video.videoWidth / video.videoHeight;
            const canvasRatio = WIDTH / HEIGHT;

            let sourceX = 0;
            let sourceY = 0;
            let sourceWidth = video.videoWidth;
            let sourceHeight = video.videoHeight;
            
            // 画面表示は「スマホ画面にフィット」だが、撮影は「画面中央を基準に切り出し」
            // 縦横比の違いを吸収し、中央部分をフルHDで取得
            if (videoRatio > canvasRatio) { 
                // 動画の横幅が広すぎる場合 (例: PCカメラ)
                sourceWidth = video.videoHeight * canvasRatio;
                sourceX = (video.videoWidth - sourceWidth) / 2;
            } else if (videoRatio < canvasRatio) { 
                // 動画の縦幅が広すぎる場合 (例: スマホ縦持ち)
                sourceHeight = video.videoWidth / canvasRatio;
                sourceY = (video.videoHeight - sourceHeight) / 2;
            }
            
            // 映像をフルHDキャンバスに描画
            context.drawImage(video, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, WIDTH, HEIGHT);
            
            // 2. キャラクター画像をcanvasに重ねて描画
            
            // キャラクター画像をフルHDのCanvasの中央に縦横比を維持して描画
            const charImg = characterOverlay;
            const charRatio = charImg.naturalWidth / charImg.naturalHeight;
            
            // Canvasに対するキャラクターの表示サイズを計算
            let drawWidth, drawHeight, drawX, drawY;

            // キャラクターの描画領域をCanvasの幅の約80%として計算 (CSSの80vwに近い感覚)
            const targetCanvasWidth = WIDTH * 0.8;
            const targetCanvasHeight = HEIGHT * 0.8; 
            
            if (charRatio > 1) { // 横長キャラの場合
                drawWidth = targetCanvasWidth;
                drawHeight = drawWidth / charRatio;
                
                // 縦長の場合、高さの制約も考慮
                if (drawHeight > targetCanvasHeight) {
                    drawHeight = targetCanvasHeight;
                    drawWidth = drawHeight * charRatio;
                }
            } else { // 縦長または正方形キャラの場合
                drawHeight = targetCanvasHeight;
                drawWidth = drawHeight * charRatio;

                // 横長の場合、幅の制約も考慮
                if (drawWidth > targetCanvasWidth) {
                    drawWidth = targetCanvasWidth;
                    drawHeight = drawWidth / charRatio;
                }
            }
            
            // Canvasの中央に配置するための座標を計算
            drawX = (WIDTH - drawWidth) / 2;
            drawY = (HEIGHT - drawHeight) / 2;
            
            // キャラクターをCanvasに描画
            context.drawImage(charImg, drawX, drawY, drawWidth, drawHeight);

            // 3. ダウンロード処理
            const dataURL = canvas.toDataURL('image/png'); 
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = `photo-${getTimestamp()}.png`; // 7. タイムスタンプ付きファイル名
            a.click();
        }

        // イベントリスナー
        captureButton.addEventListener('click', takePicture);

        // 初期化
        window.onload = startCamera;
        
    </script>
</body>
</html>