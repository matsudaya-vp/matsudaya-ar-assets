<!DOCTYPE html>
<html lang="ja">
<head>


<!-- Google tag (gtag.js) -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-KQF1C4JVNB"></script>

<script>

window.dataLayer = window.dataLayer || [];

function gtag(){dataLayer.push(arguments);}

gtag('js', new Date());



gtag('config', 'G-KQF1C4JVNB');

</script>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sample Photo Frame</title>

<style>
  /* 元の基本構造を維持 */
  body { 
    margin: 0; 
    overflow: hidden; 
    background: #000; 
    touch-action: manipulation;
  }

  /* 元の表示方式を復元 */
  #video-feed, #character-overlay {
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    object-fit: cover;
    z-index: 1;
  }

  #character-overlay { 
    z-index: 2; 
    /* PNG透過保持 */
    background: transparent;
  }

#ui-container {
  position: fixed;
  bottom: calc(8.5dvh + 1vw); /* 例として、下から20%の位置 */
  width: 100%;
  display: flex;
  justify-content: center;
  z-index: 3;
}

  #capture-button {
    width: 15vw;
    height: 15vw;
    padding: 0;
    font-size: 0;
    border-radius: 50%;
    cursor: pointer;
    background: #E0E0E0;
    color: transparent; 
    border: 4px double #808080;
    box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    transform: translateY(-50%); 
    transition: all 0.2s ease;
    user-select: none;
  }

  #capture-button:active {
    transform: translateY(-50%) scale(0.95);
  }

  /* 改善機能のスタイル */
  .progress-overlay {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    z-index: 4;
    display: none;
  }

  .camera-flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: white;
    z-index: 9999;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.1s ease;
  }

  .flash-active {
    opacity: 0.7;
  }

  .error-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(244, 67, 54, 0.95);
    color: white;
    padding: 20px;
    border-radius: 12px;
    z-index: 10;
    text-align: center;
    max-width: 80%;
    display: none;
  }

  .button-processing {
    opacity: 0.7;
    pointer-events: none;
  }
</style>
</head>

<body>
<video id="video-feed" autoplay playsinline muted></video>
<img id="character-overlay" src="img/pf-sample.png" alt="高杉晋作">
<div id="ui-container">
  <button id="capture-button" aria-label="写真を撮影"></button>
</div>

<!-- 改善機能の要素 -->
<div id="progress-overlay" class="progress-overlay"></div>
<div id="camera-flash" class="camera-flash"></div>
<div id="error-display" class="error-display"></div>

<script>
'use strict';

/**
 * 改善されたPhotoFrameアプリ
 * 元の動作を保持しつつ、必要最小限の機能改善を実装
 */
class ImprovedPhotoFrame {
  constructor() {
    // DOM要素の取得
    this.video = document.getElementById('video-feed');
    this.overlay = document.getElementById('character-overlay');
    this.captureButton = document.getElementById('capture-button');
    this.progressOverlay = document.getElementById('progress-overlay');
    this.cameraFlash = document.getElementById('camera-flash');
    this.errorDisplay = document.getElementById('error-display');
    
    // 設定
    this.config = {
      capture: { width: 1080, height: 1920, quality: 0.95 },
      camera: { 
        video: { 
          facingMode: 'environment', 
          width: { ideal: 2436 }, 
          height: { ideal: 1125 } 
        } 
      }
    };
    
    // 状態管理
    this.isCapturing = false;
    this.stream = null;
    
    // 初期化
    this.init();
  }

  async init() {
    try {
      await this.initCamera();
      await this.waitForOverlay();
      this.setupEvents();
      console.log('App initialized successfully');
    } catch (error) {
      this.showError('初期化に失敗しました: ' + error.message);
    }
  }

  async initCamera() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia(this.config.camera);
      this.video.srcObject = this.stream;
      
      return new Promise((resolve, reject) => {
        this.video.onloadedmetadata = () => resolve();
        this.video.onerror = () => reject(new Error('ビデオ読み込みエラー'));
        setTimeout(() => reject(new Error('カメラ初期化タイムアウト')), 10000);
      });
    } catch (error) {
      if (error.name === 'NotAllowedError') {
        throw new Error('カメラの使用が許可されていません');
      }
      throw new Error('カメラアクセスエラー: ' + error.message);
    }
  }

  async waitForOverlay() {
    if (this.overlay.complete) return;
    
    return new Promise((resolve, reject) => {
      this.overlay.onload = () => resolve();
      this.overlay.onerror = () => reject(new Error('オーバーレイ画像の読み込みに失敗'));
      setTimeout(() => reject(new Error('画像読み込みタイムアウト')), 5000);
    });
  }

  setupEvents() {
    // 撮影ボタン（シンプルなデバウンス）
    let lastClick = 0;
    this.captureButton.addEventListener('click', (e) => {
      const now = Date.now();
      if (now - lastClick < 300) return; // 300ms デバウンス
      lastClick = now;
      this.handleCapture();
    });

    // ページ可視性の制御
    document.addEventListener('visibilitychange', () => {
      if (this.stream) {
        const tracks = this.stream.getVideoTracks();
        tracks.forEach(track => {
          track.enabled = !document.hidden;
        });
      }
    });

    // リソースクリーンアップ
    window.addEventListener('beforeunload', () => this.cleanup());
  }

  async handleCapture() {
    if (this.isCapturing) return;
    
    try {
      this.isCapturing = true;
      this.captureButton.classList.add('button-processing');
      
      // プログレス表示
      this.showProgress('撮影中...');
      
      // フラッシュエフェクト
      await this.flashEffect();
      

      // ★★★ ここにGA4イベント計測コードを追加 ★★★
      if (typeof gtag === 'function') {
          gtag('event', 'photo_taken', {
              'event_category': 'ar_capture',
              'event_label': '高杉晋作_双写'
          });
          console.log('GA4 event: photo_taken sent');
      }
      // ★★★ 追加ここまで ★★★


      // 撮影処理
      this.showProgress('画像処理中...');
      const blob = await this.capturePhoto();
      
      // ダウンロード
      this.showProgress('保存中...');
      this.downloadImage(blob);
      
      // 完了
      this.hideProgress();
      
      // ハプティックフィードバック
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
      
    } catch (error) {
      this.hideProgress();
      this.showError('撮影に失敗しました: ' + error.message);
    } finally {
      this.isCapturing = false;
      this.captureButton.classList.remove('button-processing');
    }
  }

  async capturePhoto() {
    const canvas = document.createElement('canvas');
    const { width, height, quality } = this.config.capture;
    
    canvas.width = width;
    canvas.height = height;
    
    // 透過保持のためのContext設定
    const ctx = canvas.getContext('2d', { alpha: true });
    
    // 背景を透明にクリア（重要：白で塗りつぶさない）
    ctx.clearRect(0, 0, width, height);
    
    // ビデオの描画（中央クロップ）
    this.drawCroppedImage(ctx, this.video, width, height);
    
    // オーバーレイの描画（透過保持）
    ctx.globalCompositeOperation = 'source-over';
    this.drawCroppedImage(ctx, this.overlay, width, height);
    
    // Blobに変換
    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('画像の生成に失敗しました'));
        }
      }, 'image/png', quality);
    });
  }

  drawCroppedImage(ctx, source, targetWidth, targetHeight) {
    const sourceWidth = source.videoWidth || source.naturalWidth;
    const sourceHeight = source.videoHeight || source.naturalHeight;
    
    if (!sourceWidth || !sourceHeight) {
      throw new Error('ソース画像のサイズを取得できません');
    }
    
    const sourceRatio = sourceWidth / sourceHeight;
    const targetRatio = targetWidth / targetHeight;
    
    let sx, sy, sw, sh;
    
    if (sourceRatio > targetRatio) {
      // ソースの方が横長：横をクロップ
      sh = sourceHeight;
      sw = sh * targetRatio;
      sx = (sourceWidth - sw) / 2;
      sy = 0;
    } else {
      // ソースの方が縦長：縦をクロップ
      sw = sourceWidth;
      sh = sw / targetRatio;
      sx = 0;
      sy = (sourceHeight - sh) / 2;
    }
    
    ctx.drawImage(source, sx, sy, sw, sh, 0, 0, targetWidth, targetHeight);
  }

  downloadImage(blob) {
    const timestamp = new Date().toISOString()
      .replace(/[-:T]/g, '')
      .slice(0, 14);
    
    const link = document.createElement('a');
    link.download = `matsudaya_photo_${timestamp}.png`;
    link.href = URL.createObjectURL(blob);
    
    // 一時的にDOMに追加してクリック
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // メモリクリーンアップ
    setTimeout(() => URL.revokeObjectURL(link.href), 100);
  }

  async flashEffect() {
    this.cameraFlash.classList.add('flash-active');
    await this.delay(100);
    this.cameraFlash.classList.remove('flash-active');
  }

  showProgress(message) {
    this.progressOverlay.textContent = message;
    this.progressOverlay.style.display = 'block';
  }

  hideProgress() {
    this.progressOverlay.style.display = 'none';
  }

  showError(message) {
    console.error(message);
    this.errorDisplay.innerHTML = `
      <p>${message}</p>
      <button onclick="this.parentElement.style.display='none'">閉じる</button>
    `;
    this.errorDisplay.style.display = 'block';
    
    // 5秒後に自動で閉じる
    setTimeout(() => {
      this.errorDisplay.style.display = 'none';
    }, 5000);
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  cleanup() {
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
      this.stream = null;
    }
  }
}

// アプリケーション開始
let app;
document.addEventListener('DOMContentLoaded', () => {
  app = new ImprovedPhotoFrame();
});

// グローバルエラーハンドリング
window.addEventListener('error', (e) => {
  console.error('Global error:', e.error);
});

window.addEventListener('unhandledrejection', (e) => {
  console.error('Unhandled rejection:', e.reason);
});

</script>


<!-- Counter.dev tracking -->
<script src="https://cdn.counter.dev/script.js" data-id="271a3bee-ab75-4a8c-b0e1-ac97531ea024" data-utcoffset="9"></script>


</body>
</html>